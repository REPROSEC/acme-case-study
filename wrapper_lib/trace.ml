open Acme

module MyMap = Map.Make(String)


(** Mapping between DY_Crypto bytes and "real-world" OCaml strings *)
let __bytes_string_mapping = ref MyMap.empty


(** Recursively searches for the lowest value of any nonce inside the given bytes and returns the
   minimum of [current_min] and that value. *)
let rec min_nonce_value_in_bytes current_min t =
  let recurse t = min_nonce_value_in_bytes current_min t in
  let open DY_Crypto in
  match t with
  | Literal _ -> current_min
  | Nonce (v, _, _) -> min current_min (Z.to_int v)
  | PK t
    | CEOgen t
    | Hash t -> recurse t
  | Concat (t1, t2)
    | PKEnc (t1, t2)
    | Derive (t1, t2, _)
    | AEnc (t1, t2, None)
    | Sig (t1, t2)
    | Mac (t1, t2)
    | DEOgen (t1, t2)
    | DH (t1, t2)
    | BadDH (t1, t2) -> min (recurse t1) (recurse t2)
  | AEnc (t1, t2, Some t3) -> min (recurse t1) (recurse t2) |> min (recurse t3)


(** Convert an OCaml string to a [DY_Crypto.Nonce] using an internal lookup table. I.e., for the
   same string, this function will always return the same nonce. Basically an ideal random oracle.
   If the given string does not refer to a nonce, an [Invalid_argument] exception is raised.  If the
   given string is not in the internal lookup table, a fresh nonce will be created.  *)
let string_to_nonce s =
  match MyMap.find_opt s !__bytes_string_mapping with
  | Some DY_Crypto.Nonce _ as nonce -> Option.get nonce
  | Some not_a_nonce -> raise (Invalid_argument (DY_Crypto.sprint_bytes not_a_nonce ^ " is not a nonce!"))
  | None ->
     (* Find unused nonce value. Note that we assume here that all nonces generated by the wrapped
        F* code have positive values - which is baked into the DY_Crypto definition of nonces. I.e.,
        as long as the DY* model's nonce definition does not change, this assumption holds true. We
        need to make this assumption because of how nonces are generated: They may be implicitly
        generated by the "outside" world, e.g., by some communication partner on the internet which
        generates some random string - such a random string is represented as a nonce in DY*. This
        wrapper code has to "translate" between the DY* world and the outside world and thus needs
        to "translate" such a random string from the outside to a nonce. As the name "nonce"
        suggests, these should be unique, i.e., when coming up with new nonces, we have to make sure
        that the new nonce's value is not used anywhere (not even "internally" by the DY* model). *)
     let max_nonce_value = MyMap.fold (fun _ n -> min (min_nonce_value_in_bytes 0 n)) (!__bytes_string_mapping) 0 in
     let value = Prims.of_int (max_nonce_value - 1) in
     (* Note that we don't really care about the label and usage here *)
     let label = DY_Labels.readable_by_any1 "Produced by trace.ml" in
     let usage = DY_Crypto.nonce_usage in
     let new_nonce = DY_Crypto.Nonce (value, label, usage) in
     __bytes_string_mapping := MyMap.add s new_nonce !__bytes_string_mapping;
     new_nonce


(** Convert an OCaml string to a [DY_Crypto.bytes] using an internal lookup table. I.e., for the same
   string, this function will always return the same bytes. Returns [None] if the string is not
   associated with bytes yet. *)
let string_to_bytes s = MyMap.find_opt s !__bytes_string_mapping


(** Convert an OCaml string to a [DY_Crypto.bytes] using an internal lookup table. I.e., for the same
   string, this function will always return the same bytes.
@raise Not_found if the string is not associated with bytes yet. *)
let string_to_bytes_exn s =
  match string_to_bytes s with
  | Some t -> t
  | None -> raise Not_found


(** Convert a DY_Crypto nonce to an OCaml string, using a lookup table. Note that only nonces given
   to [string_to_nonce] or [extend_nonce_string_mapping] before can be converted. *)
let bytes_to_string n =
  let rec find_entry_by_value v l =
    if List.length l = 0 then
      None
    else if snd (List.hd l) = v then
      Some (fst (List.hd l))
    else
      find_entry_by_value v (List.tl l)
  in
  find_entry_by_value n (MyMap.bindings !__bytes_string_mapping)


(** Convert a DY_Crypto nonce to an OCaml string, using a lookup table. Note that only nonces given
   to [string_to_nonce] or [extend_nonce_string_mapping] before can be converted.
@raise Not_found if the given nonce has not been registered yet. *)
let bytes_to_string_exn n =
  match bytes_to_string n with
  | Some v -> v
  | None -> raise Not_found


(** Add a nonce <-> string mapping to the internal map. Can be used to insert nonce/string mappings
   where the nonce is generated by the F* code and the string is generated by the wrapper code
   (e.g., crypto keys).
@raise Invalid_argument if either string or nonce are already in the mapping *)
let extend_nonce_string_mapping n s =
  if Option.is_some (MyMap.find_opt s !__bytes_string_mapping) then (
    raise (Invalid_argument "String already in mapping!")
  ) else if Option.is_some (bytes_to_string n) then (
    raise (Invalid_argument "Nonce already in mapping!")
  ) else (
    __bytes_string_mapping := MyMap.add s n !__bytes_string_mapping;
  )
